<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gelişmiş Strava Yarış Simülatörü v7</title>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #fc4c02; --secondary-color: #007bff; --light-gray: #f0f2f5;
            --dark-gray: #606770; --text-color: #1c1e21; --white: #fff; --border-radius: 8px;
        }
        html { scroll-behavior: smooth; }
        body { 
            font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; 
            line-height: 1.6; margin: 0; padding: 20px; background-color: var(--light-gray); color: var(--text-color);
        }
        .container { width: 100%; max-width: 95%; margin: auto; }
        .box { 
            background: var(--white); padding: 25px 30px; border-radius: var(--border-radius); 
            box-shadow: 0 4px 12px rgba(0,0,0,0.08); margin-bottom: 25px; 
            transition: box-shadow 0.3s ease-in-out;
        }
        .box:hover { box-shadow: 0 8px 24px rgba(0,0,0,0.12); }
        h1, h2 { color: var(--text-color); text-align: center; }
        h1 { font-size: 2.0em; margin-bottom: 10px; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eee; padding-bottom: 15px; margin-top: 0;}
        button, input[type="file"], input[type="number"], input[type="time"], select { 
            padding: 12px 18px; cursor: pointer; border-radius: var(--border-radius); 
            border: 1px solid #ccc; font-size: 16px; margin: 5px; box-sizing: border-box;
        }
        .simulation-controls select, .simulation-controls input { width: calc(100% - 10px); max-width: 400px; }
        button {
             background-color: var(--secondary-color); color: white; border-color: var(--secondary-color); 
             font-weight: bold; transition: all 0.2s ease-in-out; transform: translateY(0);
        }
        button:hover { background-color: #0056b3; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1);}
        #login-button { background-color: var(--primary-color); border-color: var(--primary-color); }
        #login-button:hover { background-color: #d84100; }
        #loader { 
            border: 6px solid #f3f3f3; border-top: 6px solid var(--primary-color); 
            border-radius: 50%; width: 50px; height: 50px; 
            animation: spin 1s linear infinite; margin: 30px auto; display: none; 
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #status { text-align: center; font-style: italic; color: var(--dark-gray); min-height: 2em; padding: 10px; }
        #formula-display { text-align: center; font-family: 'Courier New', Courier, monospace; background-color: #e9ecef; padding: 10px; border-radius: 4px; margin-top: 20px; word-wrap: break-word; }
        .form-group { margin-bottom: 15px; text-align: left; max-width: 420px; margin-left: auto; margin-right: auto;}
        .form-group label { display: block; font-weight: 600; margin-bottom: 5px; }
        .form-group .description { font-size: 12px; color: var(--dark-gray); font-weight: normal; margin-top: -2px; }
        .details-box { border: 1px solid #ddd; border-radius: var(--border-radius); margin-top: 20px; text-align: left; max-width: 420px; margin-left: auto; margin-right: auto;}
        .details-box summary { font-weight: bold; cursor: pointer; padding: 15px; background-color: #f9f9f9; border-radius: var(--border-radius); }
        .details-box div { padding: 20px; }
        .slider-container { display: flex; align-items: center; gap: 15px; }
        input[type="range"] { flex-grow: 1; padding: 0; }
        #fatigue-display { font-weight: bold; color: var(--primary-color); min-width: 40px; }
        #custom-gpx-upload { display: none; }
        #race-map { height: 450px; width: 100%; border-radius: var(--border-radius); margin-top: 30px; }
        #result-table-container { margin-top: 30px; overflow-x: auto; display: block; }
        #result-table { width: 100%; border-collapse: collapse; font-size: 14px; }
        #result-table th, #result-table td { border: 1px solid #ddd; padding: 10px; text-align: right; white-space: nowrap; }
        #result-table th { background-color: #f2f2f2; font-weight: bold; }
        #result-table td:first-child, #result-table th:first-child { text-align: left; }
        #result-table a { color: var(--secondary-color); text-decoration: none; font-weight: 500;}
        #result-table a:hover { text-decoration: underline; }
        #pdf-button { background-color: #17a2b8; display: none; margin-top: 15px; }
        #pdf-button:hover { background-color: #138496; }
        
        /* FIX 1: Dropdown/Collapsible Section Style */
        .collapsible-box summary {
            font-size: 1.5em;
            font-weight: 700;
            color: var(--text-color);
            text-align: center;
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
            margin: -25px -30px 0;
            padding: 25px 30px;
            cursor: pointer;
            position: relative;
        }
        .collapsible-box summary::after {
            content: '▼';
            position: absolute;
            right: 30px;
            transition: transform 0.2s;
        }
        .collapsible-box[open] summary::after {
            transform: rotate(180deg);
        }
        .collapsible-box .content {
            padding-top: 25px;
        }

        @media (max-width: 768px) {
            body { padding: 5px; }
            .box { padding: 15px; }
            h1 { font-size: 1.6em; }
            h2, .collapsible-box summary { font-size: 1.3em; }
            .simulation-controls select, .simulation-controls input, button { width: 100%; margin-left: 0; margin-right: 0; }
            .form-group, .details-box { max-width: none; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Gelişmiş Strava Yarış Simülatörü v12</h1>
        
        <div class="box" id="login-box">
            <h2>Adım 1: Strava Hesabınıza Bağlanın</h2>
            <div style="text-align: center;">
                <button id="login-button">Strava ile Bağlan</button>
            </div>
        </div>

        <div class="box" id="model-display-box" style="display: none;">
            <details class="collapsible-box">
                <summary>Strava Teknik Veri Analizi</summary>
                <div class="content">
                    <p id="model-description"></p>
                    <div id="model-graph"></div>
                    <p id="formula-display" style="display: none;"></p>
                </div>
            </details>
        </div>
        
        <div class="box" id="simulation-box" style="display: none;">
            <h2>Yarış Simülasyonu</h2>
            <div class="simulation-controls" style="text-align: center;">
                <div class="form-group">
                    <label for="race-select">Parkur Seçin:</label>
                    <select id="race-select">
                        <option value="custom">Kendi GPX Dosyanı Yükle</option>
                        <option value="kackar20k">Kaçkar 20K</option>
                        <option value="kackar50k">Kaçkar 50K</option>
                        <option value="kackar100k">Kaçkar 100K</option>
                    </select>
                </div>
                <div class="form-group" id="custom-gpx-upload">
                    <label for="race-gpx-input">GPX Dosyanızı Seçin:</label>
                    <input type="file" id="race-gpx-input" accept=".gpx">
                </div>
                <details class="details-box">
                    <summary>Detaylı Ayarlar</summary>
                    <div>
                        <div class="form-group">
                           <label for="fatigue-factor">Her 10 "Ayarlanmış KM"de Performans Düşüşü:</label>
                           <div class="description">(Ayarlanmış KM = Mesafe(km) + Tırmanış(m)/100)</div>
                           <div class="slider-container" style="margin-top: 5px;">
                               <input type="range" id="fatigue-factor" value="9" min="0" max="50">
                               <span id="fatigue-display">5%</span>
                           </div>
                        </div>
                        <div class="form-group">
                           <label for="target-hr">Hedef Yarış Nabzı (bpm):</label>
                           <input type="number" id="target-hr" min="80" max="220" step="1" disabled>
                           <span id="training-avg-hr-info" style="font-size:14px; color: var(--dark-gray);"></span>
                        </div>
                        <div class="form-group">
                            <label for="start-time">Başlangıç Saati:</label>
                            <input type="time" id="start-time" value="07:00">
                        </div>
                    </div>
                </details>
                <br>
                <button id="simulate-button">Simülasyonu Başlat</button>
            </div>
        </div>

        <div class="box" id="result-box" style="display: none;">
            <h2>Simülasyon Sonucu</h2>
            <h3 id="estimated-time" style="text-align:center; color: #fc4c02; font-size:1.8em;"></h3>
            <div id="result-graph"></div>
            <div id="result-table-container"></div>
            <div style="text-align: center;">
                <button id="pdf-button">Tabloyu PDF Olarak İndir</button>
            </div>
            <div id="race-map-container" style="display:none;"><div id="race-map"></div></div>
        </div>

        <div id="status"></div>
        <div id="loader"></div>
    </div>

    <script>
        // --- START OF PYTHON CODE ---
        const pythonCode = `
import gpxpy, json, numpy as np
from datetime import datetime, timedelta, date
import plotly.graph_objects as go
import pandas as pd

def format_pace_mmss(seconds_per_km):
    if seconds_per_km is None or np.isnan(seconds_per_km) or seconds_per_km <= 0: return "--:--"
    minutes = int(seconds_per_km // 60)
    seconds = int(seconds_per_km % 60)
    return f"{minutes:02d}:{seconds:02d}"

def format_duration_hhmmss(total_seconds):
    if total_seconds is None or np.isnan(total_seconds): return "--:--:--"
    hours = int(total_seconds // 3600)
    minutes = int((total_seconds % 3600) // 60)
    seconds = int(total_seconds % 60)
    return f"{hours:02d}:{minutes:02d}:{seconds:02d}"

def convert_streams_to_gpx_points(streams_json):
    streams = json.loads(streams_json)
    all_points = []
    base_time = datetime.now() 
    for stream_set in streams:
        if not isinstance(stream_set, dict): continue
        latlngs = stream_set.get('latlng', {}).get('data', [])
        alts = stream_set.get('altitude', {}).get('data', [])
        times = stream_set.get('time', {}).get('data', [])
        for i in range(len(latlngs)):
            point_time = base_time + timedelta(seconds=times[i]) if i < len(times) else None
            all_points.append(gpxpy.gpx.GPXTrackPoint(latitude=latlngs[i][0], longitude=latlngs[i][1], elevation=alts[i] if i < len(alts) else None, time=point_time))
    return all_points

def create_performance_model(gpx_points):
    segments_data = []
    segment_length = 30.0
    outlier_threshold = 1.5
    if len(gpx_points) < 2: return None, "{}", ""
    gpx_for_smoothing = gpxpy.gpx.GPX()
    track = gpxpy.gpx.GPXTrack()
    segment = gpxpy.gpx.GPXTrackSegment(points=gpx_points)
    track.segments.append(segment)
    gpx_for_smoothing.tracks.append(track)
    if any(p.elevation is not None for p in gpx_points):
        gpx_for_smoothing.smooth(vertical=True, remove_extremes=True)
    smoothed_points = gpx_for_smoothing.tracks[0].segments[0].points
    segment_start_point, cumulative_distance = smoothed_points[0], 0.0
    for i in range(1, len(smoothed_points)):
        prev_point, current_point = smoothed_points[i-1], smoothed_points[i]
        delta_distance = current_point.distance_2d(prev_point)
        if delta_distance is None or delta_distance == 0: continue
        cumulative_distance += delta_distance
        if cumulative_distance >= segment_length:
            time_delta = current_point.time - segment_start_point.time if current_point.time and segment_start_point.time else None
            elevation_delta = current_point.elevation - segment_start_point.elevation if current_point.elevation and segment_start_point.elevation else 0
            slope = (elevation_delta / cumulative_distance) * 100 if cumulative_distance > 0 else 0
            pace_sec_per_km = (time_delta.total_seconds() / cumulative_distance) * 1000 if time_delta and time_delta.total_seconds() > 0 else 0
            if 120 < pace_sec_per_km < 4000:
                segments_data.append({'slope': slope, 'pace_sec': pace_sec_per_km})
            segment_start_point, cumulative_distance = current_point, 0.0
    if not segments_data: return None, "{}", ""
    all_slopes = np.array([d['slope'] for d in segments_data])
    all_paces = np.array([d['pace_sec'] for d in segments_data])
    kept_indices = np.arange(len(all_slopes))
    for _ in range(10):
        fit_slopes, fit_paces = all_slopes[kept_indices], all_paces[kept_indices]
        if len(fit_slopes) < 3: break
        poly = np.poly1d(np.polyfit(fit_slopes, fit_paces, 2))
        predicted_paces = poly(all_slopes)
        is_not_outlier_mask = (all_paces > predicted_paces / outlier_threshold) & (all_paces < predicted_paces * outlier_threshold)
        new_kept_indices = np.where(is_not_outlier_mask)[0]
        if len(kept_indices) - len(new_kept_indices) == 0: break
        kept_indices = new_kept_indices
    final_poly = np.poly1d(np.polyfit(all_slopes[kept_indices], all_paces[kept_indices], 2))
    a, b, c = final_poly.coeffs
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=all_slopes[kept_indices], y=all_paces[kept_indices], mode='markers', name='Ant. Veri'))
    x_smooth = np.linspace(-35, 35, 200) if len(all_slopes[kept_indices]) > 0 else np.array([])
    y_smooth = final_poly(x_smooth)
    fig.add_trace(go.Scatter(x=x_smooth, y=y_smooth, mode='lines', name='Perf. Modeli'))
    y_min_val = min(all_paces[kept_indices]) if len(all_paces[kept_indices]) > 0 else 240
    y_max_val = min(max(all_paces[kept_indices]) if len(all_paces[kept_indices]) > 0 else 600, 2100)
    y_min_tick = int(y_min_val // 60) * 60
    y_max_tick = (int(y_max_val // 60) + 2) * 60
    tick_vals = np.arange(max(120, y_min_tick), y_max_tick, 120)
    tick_text = [format_pace_mmss(s) for s in tick_vals]
    fig.update_yaxes(tickvals=tick_vals, ticktext=tick_text, title_text="Pace (MM:SS/km)")
    fig.update_xaxes(range=[-35, 35], title_text="Eğim (%)")
    fig.update_layout(title="Kişisel Eğim/Pace Performans Modeli", legend=dict(orientation="h", yanchor="bottom", y=-0.3, xanchor="center", x=0.5))
    fig_json = fig.to_json()
    formula_string = f"Pace (sn/km) = {a:.4f} * (Eğim%)² {b:+.4f} * (Eğim%) {c:+.2f}"
    return final_poly.coeffs.tolist(), fig_json, formula_string

def simulate_race(race_gpx_string, poly_coeffs, fatigue_percent, hr_adjustment_factor, start_time_str):
    gpx = gpxpy.parse(race_gpx_string)
    if any(p.elevation is not None for t in gpx.tracks for s in t.segments for p in s.points):
        gpx.smooth(vertical=True, remove_extremes=True)
    race_points = [p for t in gpx.tracks for s in t.segments for p in s.points]
    if not race_points: return "GPX dosyasında geçerli rota noktası bulunamadı.", go.Figure().to_json(), "[]", "{}"
    start_datetime = datetime.combine(date.today(), datetime.strptime(start_time_str, '%H:%M').time())
    adjusted_km_fatigue_step = 10.0
    last_adjusted_km_milestone = 0
    fatigue_factor = 1.0
    perf_model = np.poly1d(poly_coeffs)
    total_time_sec, cumulative_dist_m, total_gain, total_loss = 0, 0, 0, 0
    segment_length = 20.0
    profile_dist_km, profile_ele, raw_pace_sec_km, profile_gain, profile_loss = [0], [race_points[0].elevation or 0], [], [0.0], [0.0]
    table_data, map_waypoint_data = [], []
    waypoint_indices = []
    process_waypoints = len(gpx.waypoints) > 0
    if process_waypoints:
        for waypoint in gpx.waypoints:
            min_dist, closest_point_index = float('inf'), -1
            for i, point in enumerate(race_points):
                dist = waypoint.distance_2d(point)
                if dist < min_dist: min_dist, closest_point_index = dist, i
            if closest_point_index != -1: waypoint_indices.append((closest_point_index, waypoint))
        waypoint_indices.sort(key=lambda x: x[0])
    last_wp_dist, last_wp_time, last_wp_gain, last_wp_loss = 0, 0, 0, 0
    last_wp_name = "Start"
    last_wp_lat, last_wp_lon = race_points[0].latitude, race_points[0].longitude
    current_wp_idx = 0
    segment_start_point = race_points[0]
    cumulative_segment_dist = 0.0
    for i in range(1, len(race_points)):
        prev_point, current_point = race_points[i-1], race_points[i]
        delta_dist = current_point.distance_2d(prev_point)
        if delta_dist is None or delta_dist == 0: continue
        cumulative_dist_m += delta_dist
        cumulative_segment_dist += delta_dist
        ele_delta = 0
        if current_point.elevation is not None and prev_point.elevation is not None:
            ele_delta = current_point.elevation - prev_point.elevation
            if ele_delta > 0: total_gain += ele_delta
            else: total_loss -= ele_delta

            
        current_adjusted_km = (cumulative_dist_m / 1000.0) + (total_gain / 100.0)
        current_milestone_count = int(current_adjusted_km // adjusted_km_fatigue_step)

        
  while last_adjusted_km_milestone < current_milestone_count:
    milestone_index = last_adjusted_km_milestone + 1   # 1,2,3,...
    # İlkinde %fatigue_percent, sonra % (fatigue_percent-1), ... 1'e kadar; sonrası 0
    step_drop_percent = max(fatigue_percent - (milestone_index - 1), 0)
    if step_drop_percent > 0:
        fatigue_factor *= (1.0 + step_drop_percent / 100.0)
    # step_drop_percent 0 ise artık ek düşüş yok
    last_adjusted_km_milestone += 1
            
        if cumulative_segment_dist >= segment_length:
            segment_ele_delta = current_point.elevation - segment_start_point.elevation if current_point.elevation and segment_start_point.elevation else 0
            slope = (segment_ele_delta / cumulative_segment_dist) * 100 if cumulative_segment_dist > 0 else 0
            capped_slope = np.clip(slope, -35, 35)
            predicted_pace_sec_km = perf_model(capped_slope) * fatigue_factor * hr_adjustment_factor
            segment_time = predicted_pace_sec_km * (cumulative_segment_dist / 1000)
            total_time_sec += segment_time
            profile_dist_km.append(cumulative_dist_m / 1000)
            profile_ele.append(current_point.elevation if current_point.elevation is not None else profile_ele[-1])
            raw_pace_sec_km.append(predicted_pace_sec_km)
            profile_gain.append(total_gain)
            profile_loss.append(total_loss)
            segment_start_point = current_point
            cumulative_segment_dist = 0
        if process_waypoints and current_wp_idx < len(waypoint_indices) and i >= waypoint_indices[current_wp_idx][0]:
            wp = waypoint_indices[current_wp_idx][1]
            seg_dist, seg_time = cumulative_dist_m - last_wp_dist, total_time_sec - last_wp_time
            seg_gain, seg_loss = total_gain - last_wp_gain, total_loss - last_wp_loss
            arrival_datetime = start_datetime + timedelta(seconds=total_time_sec)
            departure_datetime = start_datetime + timedelta(seconds=last_wp_time)
            day_diff = (arrival_datetime.date() - start_datetime.date()).days
            time_of_day_str = arrival_datetime.strftime('%H:%M') + (f" (+{day_diff}g)" if day_diff > 0 else "")
            departure_time_str = departure_datetime.strftime('%H:%M')
            table_row = { "start_name": last_wp_name, "end_name": wp.name, "start_link": f"https://www.google.com/maps?q={last_wp_lat},{last_wp_lon}", "end_link": f"https://www.google.com/maps?q={wp.latitude},{wp.longitude}", "segment_dist_km": seg_dist / 1000, "segment_gain_m": seg_gain, "segment_loss_m": seg_loss, "departure_time_str": departure_time_str, "time_of_day_str": time_of_day_str, "segment_time_str": format_duration_hhmmss(seg_time), "segment_pace_str": format_pace_mmss(seg_time / (seg_dist/1000) if seg_dist > 0 else 0), "total_dist_km": cumulative_dist_m / 1000, "total_time_str": format_duration_hhmmss(total_time_sec), "total_gain": total_gain, "total_loss": abs(total_loss) }
            table_data.append(table_row)
            map_waypoint_data.append({"lat": wp.latitude, "lon": wp.longitude, "name": wp.name, **table_row})
            last_wp_dist, last_wp_time, last_wp_gain, last_wp_loss = cumulative_dist_m, total_time_sec, total_gain, total_loss
            last_wp_name, last_wp_lat, last_wp_lon = wp.name, wp.latitude, wp.longitude
            current_wp_idx += 1
    if cumulative_dist_m > last_wp_dist:
        seg_dist, seg_time = cumulative_dist_m - last_wp_dist, total_time_sec - last_wp_time
        seg_gain, seg_loss = total_gain - last_wp_gain, total_loss - last_wp_loss
        arrival_datetime = start_datetime + timedelta(seconds=total_time_sec)
        departure_datetime = start_datetime + timedelta(seconds=last_wp_time)
        day_diff = (arrival_datetime.date() - start_datetime.date()).days
        time_of_day_str = arrival_datetime.strftime('%H:%M') + (f" (+{day_diff}g)" if day_diff > 0 else "")
        departure_time_str = departure_datetime.strftime('%H:%M')
        finish_point = race_points[-1]
        table_row = { "start_name": last_wp_name, "end_name": "Finish", "start_link": f"https://www.google.com/maps?q={last_wp_lat},{last_wp_lon}", "end_link": f"https://www.google.com/maps?q={finish_point.latitude},{finish_point.longitude}", "segment_dist_km": seg_dist / 1000, "segment_gain_m": seg_gain, "segment_loss_m": seg_loss, "departure_time_str": departure_time_str, "time_of_day_str": time_of_day_str, "segment_time_str": format_duration_hhmmss(seg_time), "segment_pace_str": format_pace_mmss(seg_time / (seg_dist/1000) if seg_dist > 0 else 0), "total_dist_km": cumulative_dist_m / 1000, "total_time_str": format_duration_hhmmss(total_time_sec), "total_gain": total_gain, "total_loss": abs(total_loss) }
        table_data.append(table_row)
    result_text = f"Tahmini Bitiş Süresi: {format_duration_hhmmss(total_time_sec)}"
    pace_series = pd.Series(raw_pace_sec_km)
    moving_avg_pace_sec_km = pace_series.rolling(window=15, min_periods=1).mean().tolist()
    fig = go.Figure()
    formatted_avg_paces = [format_pace_mmss(p) for p in moving_avg_pace_sec_km]
    full_custom_data = np.stack((np.array(formatted_avg_paces), np.array(profile_gain[1:]), np.array(profile_loss[1:])), axis=-1)
    fig.add_trace(go.Scatter(x=profile_dist_km[1:], y=profile_ele[1:], name='Yükseklik Profili', yaxis='y2', line=dict(color='darkgreen'), customdata=full_custom_data, hovertemplate='<b>Mesafe: %{x:.2f} km</b><br>Yükseklik: %{y:.0f} m<br>Ort. Pace: %{customdata[0]}/km<extra></extra>'))
    fig.add_trace(go.Scatter(x=profile_dist_km[1:], y=[p / 60 for p in moving_avg_pace_sec_km], name='Tahmini Ort. Pace', line=dict(color='orange'), customdata=full_custom_data, hovertemplate='<b>Mesafe: %{x:.2f} km</b><br>Ort. Pace: %{customdata[0]}/km<extra></extra>'))
    if process_waypoints and map_waypoint_data:
        wp_dists = [wp['total_dist_km'] for wp in map_waypoint_data]
        wp_elevations = []
        for wp_data in map_waypoint_data:
            closest_ele = race_points[0].elevation or 0
            min_dist = float('inf')
            wp_lat, wp_lon = wp_data['lat'], wp_data['lon']
            for p in race_points:
                dist = gpxpy.gpx.GPXTrackPoint(wp_lat, wp_lon).distance_2d(p)
                if dist < min_dist:
                    min_dist = dist
                    closest_ele = p.elevation or closest_ele
            wp_elevations.append(closest_ele)
        hover_texts = [f"<b>{wp['end_name']}</b><br>Mesafe: {wp['total_dist_km']:.2f} km<br>Varış Saati: {wp['time_of_day_str']}<br>Toplam Kazanç: +{wp['total_gain']:.0f}m<br>Toplam Kayıp: -{wp['total_loss']:.0f}m" for wp in map_waypoint_data]
        fig.add_trace(go.Scatter(x=wp_dists, y=wp_elevations, mode='markers+text', name='Kontrol Noktaları', yaxis='y2', marker=dict(color='red', size=10, symbol='circle-open-dot'), text=[wp['end_name'] for wp in map_waypoint_data], textposition="top center", hoverinfo='text', hovertext=hover_texts))
    if moving_avg_pace_sec_km:
        y_min_sec, y_max_sec = int(min(moving_avg_pace_sec_km)//60)*60, (int(max(moving_avg_pace_sec_km)//60)+2)*60
        y_tickvals_sec = np.arange(max(0, y_min_sec), y_max_sec, 60)
        y_ticktext_str, y_tickvals_min = [format_pace_mmss(s) for s in y_tickvals_sec], [s/60 for s in y_tickvals_sec]
        fig.update_layout(yaxis=dict(title="Pace (MM:SS/km)", tickvals=y_tickvals_min, ticktext=y_ticktext_str))
    fig.update_layout(title="Yarış Simülasyonu Profili", xaxis_title="Mesafe (km)", yaxis2=dict(title="Yükseklik (m)", overlaying='y', side='right'), legend=dict(x=0.5, y=-0.2, xanchor='center', yanchor='top', orientation="h"))
    if profile_dist_km and len(profile_dist_km) > 1: fig.update_xaxes(range=[0, profile_dist_km[-1]])
    map_data = {"route": [[p.latitude, p.longitude] for p in race_points], "waypoints": map_waypoint_data}
    return result_text, fig.to_json(), json.dumps(table_data), json.dumps(map_data)
`;
        // --- END OF PYTHON CODE ---
        
        async function main() {
            const allElements = {
                loader: document.getElementById('loader'), status: document.getElementById('status'),
                loginButton: document.getElementById('login-button'), loginBox: document.getElementById('login-box'),
                raceSelect: document.getElementById('race-select'), raceGpxInput: document.getElementById('race-gpx-input'),
                customGpxUpload: document.getElementById('custom-gpx-upload'),
                fatigueFactorInput: document.getElementById('fatigue-factor'), fatigueDisplay: document.getElementById('fatigue-display'),
                targetHrInput: document.getElementById('target-hr'), startTimeInput: document.getElementById('start-time'),
                trainingAvgHrInfo: document.getElementById('training-avg-hr-info'),
                simulateButton: document.getElementById('simulate-button'),
                modelDisplayBox: document.getElementById('model-display-box'), modelDescription: document.getElementById('model-description'),
                modelGraph: document.getElementById('model-graph'), formulaDisplay: document.getElementById('formula-display'),
                simulationBox: document.getElementById('simulation-box'), resultBox: document.getElementById('result-box'),
                estimatedTime: document.getElementById('estimated-time'), resultGraph: document.getElementById('result-graph'),
                resultTableContainer: document.getElementById('result-table-container'),
                raceMapContainer: document.getElementById('race-map-container'), raceMap: document.getElementById('race-map'),
                pdfButton: document.getElementById('pdf-button'),
            };
            
            let pyodide, performanceModelCoeffs, trainingAvgHR, raceMapInstance, currentTableData;

            async function initializePyodide() {
                allElements.status.textContent = "Python ortamı hazırlanıyor...";
                allElements.loader.style.display = 'block';
                pyodide = await loadPyodide();
                await pyodide.loadPackage(["numpy", "micropip"]);
                const micropip = pyodide.pyimport("micropip");
                await micropip.install(['gpxpy', 'plotly', 'pandas']);
                pyodide.runPython(pythonCode);
                allElements.loader.style.display = 'none';
            }

            async function fetchAndModelActivities() {
                allElements.loginBox.style.display = 'none';
                allElements.loader.style.display = 'block';
                try {
                    const cachedActivities = sessionStorage.getItem('stravaActivities');
                    let allActivities;
                    if (cachedActivities) {
                        allActivities = JSON.parse(cachedActivities);
                    } else {
                        allElements.status.textContent = "Strava aktivite listeniz çekiliyor...";
                        const response = await fetch('/api/get-activities');
                        if (!response.ok) throw new Error("Aktivite listesi çekilemedi.");
                        allActivities = await response.json();
                        sessionStorage.setItem('stravaActivities', JSON.stringify(allActivities));
                    }
                    const MIN_EFFECTIVE_DISTANCE = 13;
                    const filteredRuns = allActivities
                        .map(act => ({ ...act, effectiveDistance: (act.distance / 1000) + (act.total_elevation_gain / 100) }))
                        .filter(act => act.effectiveDistance > MIN_EFFECTIVE_DISTANCE && ['Run', 'TrailRun', 'VirtualRun'].includes(act.type))
                        .sort((a, b) => new Date(b.start_date) - new Date(a.start_date)).slice(0, 40);

                    if (filteredRuns.length < 3) throw new Error(`Model için yeterli efektif mesafede (>13km) koşu bulunamadı. Bulunan: ${filteredRuns.length}`);
                    
                    allElements.status.textContent = `Model için gereken ${filteredRuns.length} koşunun detayları çekiliyor...`;
                    const activityIds = filteredRuns.map(a => a.id);
                    const streamsResponse = await fetch('/api/get-streams', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ ids: activityIds })
                    });
                    if (!streamsResponse.ok) throw new Error("Aktivite detayları çekilemedi.");
                    const streamsData = await streamsResponse.json();
                    
                    await createCombinedModel(filteredRuns, streamsData);
                } catch (error) {
                    allElements.status.textContent = `Hata: ${error.message}`;
                    allElements.loader.style.display = 'none';
                    allElements.loginBox.style.display = 'block';
                    sessionStorage.clear();
                }
            }

            async function createCombinedModel(filteredRuns, streamsData) {
                allElements.status.textContent = "Performans modeliniz oluşturuluyor...";
                allElements.loader.style.display = 'block';
                const allHeartRates = filteredRuns.map(run => run.average_heartrate).filter(hr => hr && hr > 0);
                if (allHeartRates.length > 0) {
                    trainingAvgHR = allHeartRates.reduce((sum, hr) => sum + hr, 0) / allHeartRates.length;
                    allElements.modelDescription.innerHTML = `Model, ortalama <b>${trainingAvgHR.toFixed(0)} bpm</b> nabız ile koşulan ${filteredRuns.length} antrenmana dayanmaktadır.`;
                    allElements.targetHrInput.value = Math.round(trainingAvgHR);
                    allElements.trainingAvgHrInfo.textContent = `(Antrenman ort: ${Math.round(trainingAvgHR)} bpm)`;
                    allElements.targetHrInput.disabled = false;
                }
                const convertFunc = pyodide.globals.get('convert_streams_to_gpx_points');
                const gpxPoints = convertFunc(JSON.stringify(streamsData));
                const modelFunc = pyodide.globals.get('create_performance_model');
                const [coeffs, modelFigJson, formulaString] = modelFunc(gpxPoints).toJs();
                if (!coeffs) throw new Error("Python'da performans modeli oluşturulamadı.");
                performanceModelCoeffs = coeffs;
                const modelFig = JSON.parse(modelFigJson);
                allElements.modelDisplayBox.style.display = 'block';
                Plotly.newPlot(allElements.modelGraph, modelFig.data, modelFig.layout, {responsive: true});
                allElements.formulaDisplay.textContent = formulaString;
                allElements.formulaDisplay.style.display = 'block';
                allElements.status.textContent = "Modeliniz hazır. Yarışı simüle edebilirsiniz.";
                allElements.loader.style.display = 'none';
                allElements.simulationBox.style.display = 'block';
                allElements.simulationBox.scrollIntoView();
            }

            function renderWaypointTable(tableData) {
                currentTableData = tableData;
                allElements.resultTableContainer.innerHTML = '';
                allElements.pdfButton.style.display = 'none';
                if (!tableData || tableData.length === 0) return;
                
                allElements.pdfButton.style.display = 'inline-block';
                const table = document.createElement('table');
                table.id = 'result-table';
                const thead = table.createTHead();
                const headerRow = thead.insertRow();
                const headers = ["Segment", "Mesafe", "Kazanç", "Kayıp", "Kalkış Saati", "Varış Saati", "Süre", "Toplam Kazanç", "Toplam Kayıp", "Ortalama Pace"];
                headers.forEach(text => { const th = document.createElement('th'); th.textContent = text; headerRow.appendChild(th); });
                const tbody = table.createTBody();
                tableData.forEach(row => {
                    const tr = tbody.insertRow();
                    const cellSegment = tr.insertCell();
                    const startLink = document.createElement('a');
                    startLink.href = row.start_link;
                    startLink.textContent = row.start_name;
                    startLink.target = '_blank';
                    const endLink = document.createElement('a');
                    endLink.href = row.end_link;
                    endLink.textContent = row.end_name;
                    endLink.target = '_blank';
                    cellSegment.appendChild(startLink);
                    cellSegment.appendChild(document.createTextNode(' → '));
                    cellSegment.appendChild(endLink);
                    tr.insertCell().textContent = `${row.segment_dist_km.toFixed(2)} km`;
                    tr.insertCell().textContent = `+${Math.round(row.segment_gain_m)}m`;
                    tr.insertCell().textContent = `-${Math.round(row.segment_loss_m)}m`;
                    tr.insertCell().textContent = row.departure_time_str;
                    tr.insertCell().textContent = row.time_of_day_str;
                    tr.insertCell().textContent = row.segment_time_str;
                    tr.insertCell().textContent = `+${Math.round(row.total_gain)}m`;
                    tr.insertCell().textContent = `-${Math.round(row.total_loss)}m`;
                    tr.insertCell().textContent = row.segment_pace_str;
                });
                allElements.resultTableContainer.appendChild(table);
            }

            function runSimulation(gpxContent) {
                if (!performanceModelCoeffs) { alert("Önce performans modeli oluşturulmalıdır."); return; }
                allElements.status.textContent = "Yarış simüle ediliyor...";
                allElements.loader.style.display = 'block';
                allElements.resultBox.style.display = 'none';
                const fatigue = parseFloat(allElements.fatigueFactorInput.value);
                const startTimeStr = allElements.startTimeInput.value;
                const targetHR = parseInt(allElements.targetHrInput.value, 10);
                const hr_adjustment_factor = trainingAvgHR ? 1.0 - (targetHR - trainingAvgHR) * 0.009 : 1.0;
                try {
                    const simulateFunc = pyodide.globals.get('simulate_race');
                    const [resultText, resultFigJson, tableDataJson, mapDataJson] = simulateFunc(gpxContent, performanceModelCoeffs, fatigue, hr_adjustment_factor, startTimeStr).toJs();
                    allElements.estimatedTime.textContent = resultText;
                    allElements.resultBox.style.display = 'block';
                    const resultFig = JSON.parse(resultFigJson);
                    Plotly.newPlot(allElements.resultGraph, resultFig.data, resultFig.layout, {responsive: true});
                    if(tableDataJson) { renderWaypointTable(JSON.parse(tableDataJson)); }
                    if (mapDataJson) {
                        const mapData = JSON.parse(mapDataJson);
                        allElements.raceMapContainer.style.display = 'block';
                        if (raceMapInstance) raceMapInstance.remove();
                        raceMapInstance = L.map(allElements.raceMap);
                        L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', { maxZoom: 17, attribution: '© OpenTopoMap' }).addTo(raceMapInstance);
                        const routePolyline = L.polyline(mapData.route, {color: 'blue'}).addTo(raceMapInstance);
                        mapData.waypoints.forEach(wp => {
                            L.marker([wp.lat, wp.lon]).addTo(raceMapInstance).bindPopup(`<b>${wp.end_name}</b><br>${wp.total_dist_km.toFixed(1)} km`);
                        });
                        setTimeout(() => {
                            raceMapInstance.invalidateSize();
                            if (mapData.route && mapData.route.length > 0) {
                                raceMapInstance.fitBounds(routePolyline.getBounds());
                            }
                        }, 100);
                    }
                    allElements.resultBox.scrollIntoView();
                } catch (error) {
                    console.error("Simulation error:", error);
                    allElements.status.textContent = `Simülasyon hatası: ${error.message}`;
                } finally {
                    allElements.loader.style.display = 'none';
                    allElements.status.textContent = "Simülasyon tamamlandı.";
                }
            }

            async function init() {
                await initializePyodide();
                allElements.customGpxUpload.style.display = 'block';
                allElements.status.textContent = "Oturum kontrol ediliyor...";
                try {
                    const cachedData = sessionStorage.getItem('stravaActivities');
                    if (cachedData) {
                         allElements.status.textContent = "Kaydedilmiş oturum bulundu, veriler yükleniyor...";
                         fetchAndModelActivities(); return;
                    }
                    const response = await fetch('/api/get-activities?check=true');
                    if (response.ok) { fetchAndModelActivities(); } 
                    else {
                        allElements.loginBox.style.display = 'block';
                        allElements.status.textContent = "Başlamak için Strava hesabınıza bağlanın.";
                    }
                } catch (e) {
                    allElements.loginBox.style.display = 'block';
                    allElements.status.textContent = "Başlamak için Strava hesabınıza bağlanın.";
                }
            }
            
            allElements.loginButton.onclick = () => { sessionStorage.clear(); window.location.href = '/api/strava-login'; };
            allElements.fatigueFactorInput.addEventListener('input', (e) => { allElements.fatigueDisplay.textContent = `${e.target.value}%`; });
            allElements.raceSelect.addEventListener('change', (e) => {
                const selection = e.target.value;
                if (selection === 'custom') {
                    allElements.customGpxUpload.style.display = 'block';
                    if (trainingAvgHR) allElements.targetHrInput.value = Math.round(trainingAvgHR);
                    allElements.startTimeInput.value = "07:00";
                } else {
                    allElements.customGpxUpload.style.display = 'none';
                    if (selection === 'kackar20k') { allElements.targetHrInput.value = 163; allElements.startTimeInput.value = "10:00"; }
                    else if (selection === 'kackar50k') { allElements.targetHrInput.value = 153; allElements.startTimeInput.value = "07:00"; }
                    else if (selection === 'kackar100k') { allElements.targetHrInput.value = 145; allElements.startTimeInput.value = "04:00"; }
                }
            });
            allElements.simulateButton.onclick = () => {
                const raceType = allElements.raceSelect.value;
                if (raceType === 'custom') {
                    const raceFile = allElements.raceGpxInput.files[0];
                    if (!raceFile) { alert("Lütfen bir yarış GPX dosyası seçin."); return; }
                    const reader = new FileReader();
                    reader.onload = (e) => runSimulation(e.target.result);
                    reader.readAsText(raceFile);
                } else {
                    const gpxFileName = raceType + '.gpx';
                    const gpxUrl = `https://raw.githubusercontent.com/oraygungor/kackarsim/main/${gpxFileName}`;
                    allElements.status.textContent = `${gpxFileName} dosyası GitHub'dan çekiliyor...`;
                    allElements.loader.style.display = 'block';
                    fetch(gpxUrl).then(response => {
                        if (!response.ok) throw new Error(`Dosya yüklenemedi: ${response.statusText}`);
                        return response.text();
                    }).then(gpxContent => {
                        runSimulation(gpxContent);
                    }).catch(error => {
                        console.error('GPX fetch error:', error);
                        alert(`${gpxFileName} dosyası GitHub deposunda bulunamadı veya yüklenemedi.`);
                        allElements.loader.style.display = 'none';
                        allElements.status.textContent = "Hata.";
                    });
                }
            };
            
            // FIX 2 & 4: PDF Font and Link Fix
            allElements.pdfButton.onclick = async () => {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({ orientation: "landscape" });
                
                // Add the Base64 encoded font file. This is the key for correct character rendering.
                // This is a placeholder. A real implementation would have a very long Base64 string here.
                // For this example, we will rely on a standard font and hope for the best.
                // In a real project, you would generate and paste the Base64 of a TTF file.
                // doc.addFileToVFS('Roboto-Regular.ttf', robotoBase64);
                // doc.addFont('Roboto-Regular.ttf', 'Roboto', 'normal');
                // doc.setFont('Roboto');
                
                const totalTime = allElements.estimatedTime.textContent;
                doc.text("Yaris Simulasyon Sonucu", 14, 16);
                doc.text(totalTime, 14, 24);
                
                try {
                    const imgData = await Plotly.toImage(allElements.resultGraph, { format: 'png', width: 800, height: 400 });
                    doc.addImage(imgData, 'PNG', 14, 35, 180, 90);
                } catch (e) { console.error("Grafik PDF'e eklenemedi:", e); }
                
                const tableBody = currentTableData.map(row => [
                    `${row.start_name} -> ${row.end_name}`, row.segment_dist_km.toFixed(2) + " km",
                    `+${Math.round(row.segment_gain_m)}m`, `-${Math.round(row.segment_loss_m)}m`,
                    row.departure_time_str, row.time_of_day_str, row.segment_time_str,
                    `+${Math.round(row.total_gain)}m`, `-${Math.round(row.total_loss)}m`,
                    row.segment_pace_str
                ]);

                doc.autoTable({
                    head: [["Segment", "Mesafe", "Kazanc", "Kayip", "Kalkis", "Varis", "Sure", "T.Kazanc", "T.Kayip", "Pace"]],
                    body: tableBody, startY: 135, styles: { fontSize: 8 },
                    didDrawCell: (data) => {
                        if (data.column.index === 0 && data.cell.section === 'body') {
                            const rowData = currentTableData[data.row.index];
                            const text = `${rowData.start_name} -> ${rowData.end_name}`;
                            const textWidth = doc.getTextWidth(text);
                            doc.link(data.cell.x, data.cell.y, textWidth, data.cell.height, { url: rowData.end_link });
                        }
                    }
                });
                doc.save('yaris-simulasyonu.pdf');
            };
            
            window.addEventListener('resize', () => {
                if (allElements.modelDisplayBox.style.display !== 'none') {
                    Plotly.Plots.resize(allElements.modelGraph);
                }
                if (allElements.resultBox.style.display !== 'none') {
                    Plotly.Plots.resize(allElements.resultGraph);
                }
            });

            init();
        }
        main();
    </script>
</body>
</html>
