<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gelişmiş Yarış Simülatörü v0.1</title>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <style>
        :root {
            --primary-color: #fc4c02;
            --secondary-color: #007bff;
            --light-gray: #f0f2f5;
            --dark-gray: #606770;
            --text-color: #1c1e21;
            --white: #fff;
            --border-radius: 8px;
        }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; 
            line-height: 1.6; 
            margin: 0; 
            padding: 20px; 
            background-color: var(--light-gray); 
            color: var(--text-color);
        }
        .container { max-width: 1000px; margin: auto; }
        .box { 
            background: var(--white); 
            padding: 25px 30px; 
            border-radius: var(--border-radius); 
            box-shadow: 0 4px 12px rgba(0,0,0,0.08); 
            margin-bottom: 25px; 
        }
        h1, h2 { color: var(--text-color); text-align: center; }
        h1 { font-size: 2.2em; margin-bottom: 10px; }
        h2 { font-size: 1.6em; border-bottom: 1px solid #eee; padding-bottom: 15px; margin-top: 0;}
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; font-weight: 600; margin-bottom: 5px; }
        .form-group .description { font-size: 12px; color: var(--dark-gray); font-weight: normal; margin-top: -2px; }
        .details-box { border: 1px solid #ddd; border-radius: var(--border-radius); margin-top: 20px;}
        .details-box summary { font-weight: bold; cursor: pointer; padding: 15px; background-color: #f9f9f9; border-radius: var(--border-radius); }
        .details-box div { padding: 20px; }
        button { background-color: var(--secondary-color); color: white; border: none; padding: 12px 18px; border-radius: var(--border-radius); font-weight: bold; cursor: pointer; }
        #login-button { background-color: var(--primary-color); }
        #loader { border: 6px solid #f3f3f3; border-top: 6px solid var(--primary-color); border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 30px auto; display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #status { text-align: center; font-style: italic; color: var(--dark-gray); min-height: 2em; padding: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Gelişmiş Yarış Simülatörü</h1>
        <div class="box" id="login-box" style="display: none;">
            <h2>Adım 1: Strava Hesabınıza Bağlanın</h2>
            <button id="login-button">Strava ile Bağlan</button>
        </div>
        <div class="box" id="model-display-box" style="display: none;">
            <h2>Adım 2: Performans Modeliniz</h2>
            <p id="model-description"></p>
            <div id="model-graph"></div>
        </div>
        <div class="box" id="simulation-box" style="display: none;">
            </div>
        <div class="box" id="result-box" style="display: none;">
            </div>
        <div id="status"></div>
        <div id="loader"></div>
    </div>
    <script>
        // --- Python code is the same as before ---
        const pythonCode = `
import gpxpy, json, numpy as np
from datetime import datetime, timedelta, date
import plotly.graph_objects as go
import pandas as pd

def format_pace_mmss(seconds_per_km):
    if seconds_per_km is None or np.isnan(seconds_per_km) or seconds_per_km <= 0: return "--:--"
    minutes = int(seconds_per_km // 60)
    seconds = int(seconds_per_km % 60)
    return f"{minutes:02d}:{seconds:02d}"

def format_duration_hhmmss(total_seconds):
    if total_seconds is None or np.isnan(total_seconds): return "--:--:--"
    hours = int(total_seconds // 3600)
    minutes = int((total_seconds % 3600) // 60)
    seconds = int(total_seconds % 60)
    return f"{hours:02d}:{minutes:02d}:{seconds:02d}"

def convert_streams_to_gpx_points(streams_json):
    streams = json.loads(streams_json)
    all_points = []
    base_time = datetime.now() 
    for stream_set in streams:
        if not isinstance(stream_set, dict): continue
        latlngs = stream_set.get('latlng', {}).get('data', [])
        alts = stream_set.get('altitude', {}).get('data', [])
        times = stream_set.get('time', {}).get('data', [])
        for i in range(len(latlngs)):
            point_time = base_time + timedelta(seconds=times[i]) if i < len(times) else None
            all_points.append(gpxpy.gpx.GPXTrackPoint(latitude=latlngs[i][0], longitude=latlngs[i][1], elevation=alts[i] if i < len(alts) else None, time=point_time))
    return all_points

def create_performance_model(gpx_points):
    segments_data = []
    segment_length = 30.0
    outlier_threshold = 1.5
    if len(gpx_points) < 2: return None, "{}", ""
    gpx_for_smoothing = gpxpy.gpx.GPX()
    track = gpxpy.gpx.GPXTrack()
    segment = gpxpy.gpx.GPXTrackSegment(points=gpx_points)
    track.segments.append(segment)
    gpx_for_smoothing.tracks.append(track)
    if any(p.elevation is not None for p in gpx_points):
        gpx_for_smoothing.smooth(vertical=True, remove_extremes=True)
    smoothed_points = gpx_for_smoothing.tracks[0].segments[0].points
    segment_start_point, cumulative_distance = smoothed_points[0], 0.0
    for i in range(1, len(smoothed_points)):
        prev_point, current_point = smoothed_points[i-1], smoothed_points[i]
        delta_distance = current_point.distance_2d(prev_point)
        if delta_distance is None or delta_distance == 0: continue
        cumulative_distance += delta_distance
        if cumulative_distance >= segment_length:
            time_delta = current_point.time - segment_start_point.time if current_point.time and segment_start_point.time else None
            elevation_delta = current_point.elevation - segment_start_point.elevation if current_point.elevation and segment_start_point.elevation else 0
            slope = (elevation_delta / cumulative_distance) * 100 if cumulative_distance > 0 else 0
            pace_sec_per_km = (time_delta.total_seconds() / cumulative_distance) * 1000 if time_delta and time_delta.total_seconds() > 0 else 0
            if 120 < pace_sec_per_km < 4000:
                segments_data.append({'slope': slope, 'pace_sec': pace_sec_per_km})
            segment_start_point, cumulative_distance = current_point, 0.0
    if not segments_data: return None, "{}", ""
    all_slopes = np.array([d['slope'] for d in segments_data])
    all_paces = np.array([d['pace_sec'] for d in segments_data])
    kept_indices = np.arange(len(all_slopes))
    for _ in range(10):
        fit_slopes, fit_paces = all_slopes[kept_indices], all_paces[kept_indices]
        if len(fit_slopes) < 3: break
        poly = np.poly1d(np.polyfit(fit_slopes, fit_paces, 2))
        predicted_paces = poly(all_slopes)
        is_not_outlier_mask = (all_paces > predicted_paces / outlier_threshold) & (all_paces < predicted_paces * outlier_threshold)
        new_kept_indices = np.where(is_not_outlier_mask)[0]
        if len(kept_indices) - len(new_kept_indices) == 0: break
        kept_indices = new_kept_indices
    final_poly = np.poly1d(np.polyfit(all_slopes[kept_indices], all_paces[kept_indices], 2))
    # Create a dummy figure to avoid Plotly errors, the real figure will be generated in JS
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=all_slopes[kept_indices], y=all_paces[kept_indices], mode='markers', name='Antrenman Verileri'))
    a, b, c = final_poly.coeffs
    x_smooth = np.linspace(min(all_slopes), max(all_slopes), 100)
    y_smooth = final_poly(x_smooth)
    fig.add_trace(go.Scatter(x=x_smooth, y=y_smooth, mode='lines', name='Performans Modeli'))
    fig_json = fig.to_json()
    formula_string = f"Pace (sn/km) = {a:.4f} * (Eğim%)² {b:+.4f} * (Eğim%) {c:+.2f}"
    return final_poly.coeffs.tolist(), fig_json, formula_string
        `;
        
        async function main() {
            const allElements = {
                loader: document.getElementById('loader'),
                status: document.getElementById('status'),
                loginButton: document.getElementById('login-button'),
                loginBox: document.getElementById('login-box'),
                modelDisplayBox: document.getElementById('model-display-box'),
                modelDescription: document.getElementById('model-description'),
                modelGraph: document.getElementById('model-graph'),
                simulationBox: document.getElementById('simulation-box'),
            };

            let pyodide;
            let performanceModelCoeffs;
            let trainingAvgHR;

            async function initializePyodide() {
                // ... same as before
            }
            
            // --- YENİ MANTIK BURADA BAŞLIYOR ---
            async function fetchAndModelActivities() {
                allElements.loginBox.style.display = 'none';
                allElements.loader.style.display = 'block';
                
                try {
                    // Check sessionStorage first
                    const cachedActivities = sessionStorage.getItem('stravaActivities');
                    const cachedStreams = sessionStorage.getItem('stravaStreams');

                    let allActivities;
                    let streamsData;

                    if (cachedActivities && cachedStreams) {
                        allElements.status.textContent = "Önbellekten alınan verilerle model oluşturuluyor...";
                        allActivities = JSON.parse(cachedActivities);
                        streamsData = JSON.parse(cachedStreams);
                    } else {
                        // PHASE 1: Fetch activity list
                        allElements.status.textContent = "Strava aktivite listeniz çekiliyor...";
                        const response = await fetch('/api/get-activities');
                        if (!response.ok) throw new Error("Aktivite listesi çekilemedi.");
                        allActivities = await response.json();
                        sessionStorage.setItem('stravaActivities', JSON.stringify(allActivities));
                    }

                    // PHASE 2: Filter activities on the client side
                    const twoMonthsAgo = new Date();
                    twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);
                    const MIN_DISTANCE = 13000;
                    const MAX_RUNS_FOR_MODEL = 40;

                    const filteredRuns = allActivities
                        .filter(act => new Date(act.start_date) > twoMonthsAgo && act.distance > MIN_DISTANCE && ['Run', 'TrailRun'].includes(act.type))
                        .sort((a, b) => new Date(b.start_date) - new Date(a.start_date))
                        .slice(0, MAX_RUNS_FOR_MODEL);

                    if (filteredRuns.length < 3) {
                        throw new Error(`Model için yeterli koşu bulunamadı (Son 2 ay, >13km). Bulunan: ${filteredRuns.length}`);
                    }

                    if (!cachedStreams) {
                        // PHASE 3: Fetch streams for ONLY the filtered activities
                        allElements.status.textContent = `Model için gereken ${filteredRuns.length} koşunun detayları çekiliyor...`;
                        const activityIds = filteredRuns.map(a => a.id);
                        const streamsResponse = await fetch('/api/get-streams', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ ids: activityIds })
                        });
                        if (!streamsResponse.ok) throw new Error("Aktivite detayları çekilemedi.");
                        streamsData = await streamsResponse.json();
                        sessionStorage.setItem('stravaStreams', JSON.stringify(streamsData));
                    }

                    // Now build the model with the detailed data
                    await createCombinedModel(filteredRuns, streamsData);

                } catch (error) {
                    allElements.status.textContent = `Hata: ${error.message}`;
                    allElements.loader.style.display = 'none';
                    allElements.loginBox.style.display = 'block';
                    sessionStorage.clear(); // Clear cache on error
                }
            }

            async function createCombinedModel(filteredRuns, streamsData) {
                // ... same as before
            }
            
            async function init() {
                await initializePyodide();
                allElements.status.textContent = "Oturum kontrol ediliyor...";
                try {
                    // Check for sessionStorage first
                    const cachedData = sessionStorage.getItem('stravaActivities');
                    if (cachedData) {
                         allElements.status.textContent = "Kaydedilmiş oturum bulundu, veriler yükleniyor...";
                         fetchAndModelActivities(); // Use cached data
                         return;
                    }
                    
                    const response = await fetch('/api/get-activities?check=true');
                    if (response.ok) {
                        fetchAndModelActivities();
                    } else {
                        allElements.loginBox.style.display = 'block';
                        allElements.status.textContent = "Başlamak için Strava hesabınıza bağlanın.";
                    }
                } catch (e) {
                    allElements.loginBox.style.display = 'block';
                    allElements.status.textContent = "Başlamak için Strava hesabınıza bağlanın.";
                }
            }
            
            allElements.loginButton.onclick = () => { 
                sessionStorage.clear(); // Clear cache before new login
                window.location.href = '/api/strava-login'; 
            };

            // Call the main function
            // main(); This seems to be a mistake from a previous version, init is the entry point
            initializePyodide().then(init); // Correct way to chain initialization
        }

        // Run the main async function
        main();
    </script>
</body>
</html>
